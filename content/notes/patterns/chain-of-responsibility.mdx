## Introduction
The Chain of Responsibility allows to decouple the source of requests from its handlers. In other words, when your object uses some external objects to do the work, instead of invoking methods of these objects directly, you get the work done with the Chain of Responsibility.

## When to use?
- when more than one object can handle the request
- when you want to have the task done without directly choosing the handler
- when handlers can be determined dynamically

## Structure
<Image src="../../assets/chain.jpg" alt="Iterator Structure" />

<br />
Common object structure may look as follows:


<br />
<br />

<Image src="../../assets/structure-chain.jpg" alt="Iterator Structure" />

<br />

## Elements
- Handler
  - defines the interface for handling requests
  - optionally implements delegating request to successor
- ConcreteHandler
  - handles certain type of requests
  - can access the successor
  - if it can't handle the requests, it passes it to the successor
- Client
  - initializes the request by passing it to one of the handlers in the chain

## Benefits & Costs
- Loose coupling - client does not know who handles the request. Both the sender and receiver of the request doesn't communicate directly
- More flexibility in assigning tasks - you can add handlers to the chain during the runtime
- Request is not guaranteed to be handled - as requests are not directed towards any particular handler directly, in some situations the request may be not handled by any handler at all

## Implementation
We'll design a mock of image compressor that can optimize various types of images. Each image type will be handled by a separate object that is designed to optimize one given type of images.

First, let's declare Image interface:
```java
public interface Image {
 String name();
 String extension();
}
```

with a simple implementation:
```java
public class ImageImpl implements Image {
 private final String name;
 private final String extension;

 public ImageImpl(final String name, final String extension) {
 this.name = name;
 this.extension = extension;
 }

 @Override
 public String name() {
 return this.name;
 }

 @Override
 public String extension() {
 return this.extension;
 }
}
```

Now, it's time to declare an abstract type of Handler (Optimizer)
```java
import static java.util.Objects.isNull;

abstract class ImageOptimizer {
 private ImageOptimizer next;

 abstract String optimize(final Image image);

 public void addNext(final ImageOptimizer optimizer) {
 if (isNull(next)) {
 this.next = optimizer;
 } else {
 this.next.addNext(optimizer);
 }
 }

 ImageOptimizer getNext() {
 return next;
 }
}
```

This abstract class declares the API for handling (optimization) requests - `optimize()`.

Each ConcreteHandler (class that is responsible for compressing a specific type of images) will have to provide an implementation of this method and delegate the request to next optimizer if it's not able to optimize requested type of image.

The abstract class also provides API for adding handlers to the chain - `addNext()`. It recursively appends handlers to the end of the chain.

Now we'll add ConcreteHandlers:
```java
public class JPGOptimizer extends ImageOptimizer {
 @Override
 public String optimize(final Image image) {
 if (image.extension().equals("jpg")) {
 return "Optimized" + image.name() + "." + image.extension() + " by JPGOptimizer.";
 }

 if (!isNull(getNext())) {
 return getNext().optimize(image);
 }

 throw new UnsupportedTypeException(image.extension() + " type cannot be optimized");
 }
}

public class UnsupportedTypeException extends RuntimeException {
 public UnsupportedTypeException(final String message) {
 super(message);
 }
}

public class PNGOptimizer extends ImageOptimizer{
 @Override
 public String optimize(final Image image) {
 if (image.extension().equals("png")) {
 return "Optimized" + image.name() + "." + image.extension() + " by PNGOptimizer.";
 }

 if (!isNull(getNext())) {
 return getNext().optimize(image);
 }

 throw new UnsupportedTypeException(image.extension() + " type cannot be optimized");
 }
}

public class BMPOptimizer extends ImageOptimizer {
 @Override
 public String optimize(final Image image) {
 if (image.extension().equals("bmp")) {
 return "Optimized" + image.name() + "." + image.extension() + " by BMPOptimizer.";
 }

 if (!isNull(getNext())) {
 return getNext().optimize(image);
 }

 throw new UnsupportedTypeException(image.extension() + " type cannot be optimized");
 }
}
```

The implementation is pretty simple - if the handler can optimize given image extension then it optimize it, otherwise, it requests next handler in the chain to optimize the image or throws exception if there's no next handler.

Let's see how client code of those classes could look like:

```java
public class Example {
 public static void main(String[] args) {
 final ImageOptimizer optimizer = new JPGOptimizer();
 final ImageOptimizer pngOptimizer = new PNGOptimizer();
 final ImageOptimizer bmpOptimizer = new BMPOptimizer();

 optimizer.addNext(pngOptimizer);
 optimizer.addNext(bmpOptimizer);

 final Image jpg = new ImageImpl("someImage", "jpg");
 final Image png = new ImageImpl("anotherImage", "png");
 final Image bmp = new ImageImpl("awfulImage", "bmp");
 final Image invalidImage = new ImageImpl("niceImage", "xml");

 System.out.println(optimizer.optimize(jpg));
 System.out.println(optimizer.optimize(png));
 System.out.println(optimizer.optimize(bmp));
 System.out.println(optimizer.optimize(invalidImage));
 }
}
```

Output of code above:
```
OptimizedsomeImage.jpg by JPGOptimizer.
OptimizedanotherImage.png by PNGOptimizer.
OptimizedawfulImage.bmp by BMPOptimizer.
Exception in thread "main" chainofresponsibility.UnsupportedTypeException: xml type cannot be optimized
 at chainofresponsibility.BMPOptimizer.optimize(BMPOptimizer.java:16)
 at chainofresponsibility.PNGOptimizer.optimize(PNGOptimizer.java:13)
 at chainofresponsibility.JPGOptimizer.optimize(JPGOptimizer.java:13)
 at chainofresponsibility.Example.main(Example.java:20)
```

## Conclusion
As you see, each image was processed by an appropriate optimizer.
When unsupported image is being optimized, the exception is thrown. Of course, you could just return unoptimized image instead of throwing an exception, but it doesn't really matter for the sake of this example.

We didn't have to specify a concrete handler to optimize the image - this was done by the chain.
The chain can be adjusted in the runtime. Adding support for a new type of image involves creating a new class instead of editing an existing one.