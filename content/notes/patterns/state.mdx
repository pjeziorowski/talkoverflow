State is a behavioural design pattern that allows easy changes of object behaviour based on its internal state. It encapsulates the logic connected to the given state to a separate class.

## When to use?
- when an object needs to change its behaviour when its inner state changes
- when you want to remove multiple if statements that determines appropriate behaviour based on internal state

## Structure
<Image src="../../assets/state.png" alt="state pattern structure" />

<br />

## Elements
- Context - defines the API, keeps a reference to concrete State implementation
- State - defines the interface to encapsulate the behaviour related to certain state
- ConcreteState - implements behaviour related to some state

## Cooperation
Context stores a reference to the state object and delegates the work that depends on an inner state. Context or State implementation must decide about state transitions.

## Consequences
- behaviour related to a given state is kept in one object and is separated
- state changes are 'highlighted'
- state objects can be reused

The pattern itself doesn't determine which object should coordinate the state transitions. It may be done either by context or concrete states. If given case is simple and straightforward then the state transitions may be orchestrated by the Context, but when it gets complicated, then it would be better to let concrete States decide about state transitions at the cost of some coupling between concrete States.

Another option is to use hashmap of state transitions - it's more flexible but operations on tables are slower than direct method invocations. It is also a bit more challenging to grasp and implement.

## Example
We're finished with the theory, let's now try to implement a simple State pattern example.

We'll create a gun that can shoot in different fire modes.

Let's first declare interfaces:
```java
public interface Weapon {
    void use();
}

// State element
public interface FireMode {
    void use(final Weapon weapon);
}
```

Before we implement a gun, let's add fire modes (Concrete State implementations):
```java
public class PiercingBullet implements FireMode {
    private static final FireMode self = new PiercingBullet();
    private static final FireMode nextFireMode = SingleShot.instance();

    // hide the constructor
    private PiercingBullet() { }

    @Override
    public void use(final Gun gun) {
        System.out.println("Fired piercing bullet! Done " + 1.5 * gun.getBaseDamage() + " damage.");
        ;
        gun.setFireMode(nextFireMode);
    }

    public static FireMode instance() {
        return self;
    }
}

public class SingleShot implements FireMode {
    private static final FireMode self = new SingleShot();
    private static final FireMode nextFireMode = TripleBullets.instance();

    // hide the constructor
    private SingleShot() { }

    @Override
    public void use(final Gun gun) {
        System.out.println("Fired single shot! Done " + gun.getBaseDamage() + " damage.");
        gun.setFireMode(nextFireMode);
    }

    public static FireMode instance() {
        return self;
    }
}

public class TripleBullets implements FireMode {
    private static final FireMode self = new TripleBullets();
    private final FireMode nextFireMode = PiercingBullet.instance();

    // hide the constructor
    private TripleBullets() { }

    @Override
    public void use(final Gun gun) {
        System.out.println("Fired three bullets! Done " + 3 * gun.getBaseDamage() + " damage.");
        gun.setFireMode(nextFireMode);
    }

    public static FireMode instance() {
        return self;
    }
}
```

Fire mode implementations are pretty similar - each implements `FireMode.use()` method, in which
they execute some business logic (firing bullets) and automatically switch to next fire mode.

Fire modes also provide a simplified version of Singleton pattern by hiding constructors and providing static
factory methods `instance()` that return appropriate FireMode object.

Now that we implemented fire modes, we can create a gun (Context element):

```java
class Gun implements Weapon {
    private final int baseDamage;
    private FireMode fireMode;

    public Gun(int baseDamage) {
        this.fireMode = SingleShot.instance();
        this.baseDamage = baseDamage;
    }

    @Override
    public void use() {
        fireMode.use(this);
    }

    int getBaseDamage() {
        return baseDamage;
    }

    void setFireMode(final FireMode fireMode) {
        this.fireMode = fireMode;
    }
}
```

Gun (Context) keeps a reference to a State object that is used in overridden `use()` weapon method.
It also provides an API to update its state that is later on used by concrete State implementations.

We can now put all the pieces together and use our gun:
```java
public class ClientCode {
    public static void main(String[] args) {
        final int baseDamage = 100;
        final Weapon gun = new Gun(baseDamage);

        gun.use();
        gun.use();
        gun.use();
        gun.use();
        // OUTPUT:
        /*
           Fired single shot! Done 100 damage.
           Fired three bullets! Done 300 damage.
           Fired piercing bullet! Done 150.0 damage.
           Fired single shot! Done 100 damage.
        */
    }
}
```

As you see, one thing we have to do is to create a gun. When we use its `shoot()` method,
the state is managed automatically and appropriate fire modes are used.