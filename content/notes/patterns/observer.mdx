## Introduction
Observer, in my opinion, is one of the most important design patterns. Its often implemented not only at the code level but also in high-level architectural concepts.

It describes a one-to-many relation in which a set of objects are notified about changes in the other object.

## When to use
- to decouple objects
- when change in one object should have an effect on one or more other objects
- when objects should be loosely coupled

## Structure
<Image src="../../assets/observer.png" alt="observer pattern structure" />

<br />

## Elements
- Subject- knows observers, can reference many observers, has an interface for adding observers
- Observer - provides an interface that allows it to be notified about changes in Subject
- ConcreteSubject - keeps a reference to a set of observers, notifies them about events/changes
- ConcreteObserver - implements a method that is invoked when observer changes

## Cooperation
Subject notifies Observer about important changes or events.

## Consequences 
- louse coupling between observers and subjects
- broadcasting events

## Code example
Enough theory - let's write some code.

In this simple example, we'll create a user repository that has API to register users.
Other services, like email service and audit service, will listen for user registration events.

Let's first define Observer API:
```java
abstract class RegistrationObserver {
 abstract void notify(final String emailRegistered);
}
```

As mentioned earlier, the Observer has API to be notified about changes/events in Subject. 
In this example, Observer expects to receive emails of newly registered users.

Now we'll add two implementations of Observer API:

```java
class AuditService extends RegistrationObserver {
 @Override
 void notify(final String emailRegistered) {
 System.out.println("Storing information about " + emailRegistered + " registration");
 }
}

class EmailService extends RegistrationObserver {
 @Override
 void notify(final String emailRegistered) {
 System.out.println("Sending welcome email to " + emailRegistered);
 }
}
```

Those classes use received email to execute some business logic like sending an email or storing information about changes in the system.

Now, we need Subject:
```java
import java.util.List;

class UserService {
 final List<RegistrationObserver> observers;

 UserService(final List<RegistrationObserver> observers) {
 this.observers = observers;
 }

 void register(final RegistrationObserver observer) {
 observers.add(observer);
 }

 void registerUser(final String userEmail, final String userPassword) {
 // save user in the database, and then...
 observers.forEach(observer -> observer.notify(userEmail));
 }
}
```

User service is our subject. It keeps a reference to a list of observers, expose API to add an observer and
contains one business method - `registerUser()` that is storing user in the database and then notifying all
observers about user registration event.

We got everything set up - it's time to make a use of our code.

```java
public class ClientCode {
 public static void main(String[] args) {
 // Creating Subject - User Service
 final List<RegistrationObserver> initialObservers = new ArrayList<>();
 final UserService userService = new UserService(initialObservers);

 // Invoking user registration with no observers subscribed
 userService.registerUser("test.user@gmail.com", "qwerty");

 // NO OUTPUT - NO OBSERVERS SUBSCRIBED

 // Adding observers
 final EmailService emailService = new EmailService();
 final AuditService auditService = new AuditService();
 userService.register(emailService);
 userService.register(auditService);

 // Registering user after registering observers
 userService.registerUser("new.user@outlook.com", "123456");

 // OUTPUT:
 // Sending welcome email to new.user@outlook.com
 // Storing information about new.user@outlook.com registration
 }
}
```

The code above is self-explanatory, so I'll skip discussing the details.

In this simple version of Observator pattern, we created a Subject that can broadcast events to a list of interested Observers. 

The only thing that the Subject knows about Observers is that they implement the required interface.

Observers, on the other hand, know nothing about the Subject and just wait for notifications.

Thanks to using the pattern, we created a broadcasting mechanism and more loosely coupled code.