## Introduction
Visitor is a behavioural design pattern that represents operations executed on elements of a data structure. It enables adding new operations without editing classes of the data structure.

## When to use?
- when you want to execute various unrelated operations
on elements of the data structure without polluting the code of those elements - instead of adding code to the classes of the data structure, you organize them in separate class
- when classes defining data structure change rarely but you often want to add new operations on those elements - when using visitor, it's easy to add a new operation on elements. However, adding a new type of element to the data structure entails implementing all operations for this type of element in all visitors.

## Structure 
<Image src="../../assets/visitor.png"/>

<br />

## Elements
- Visitor - declares one visit method for each class of the data structure
- ConcreteVisitor - implements all methods of Visitor, provides operations to apply on elements of the data structure
- Element - element of the data structure, defines the accept method that takes visitor as an argument
- ConcreteElement - implements accept method
- ObjectStructure - provides the interface that allows visitors to visit elements, it can be a collection or [composite](/posts/composite).

## Consequences 
- adding new operations on data structure is easier
- allows grouping related operations on data structure
- makes it harder to add a new type to the data structure
- enables visiting different types of elements of the data structure

## Code example
After ingesting all of the theory, let's see how this pattern works in practice and finally write some code.

In our example, we'll try to create a list of customers of various types. 
The Visitor will allow us to apply operations on elements of that list.

First, let's add interface for Customer (Element)
```java
public interface Customer {
 void accept(final Visitor visitor);
}
```

As discussed previously, the Element has a method that accepts a visitor.

Now, we need a Visitor.


We'll create a Visitor that allows applying operations on three types of customers:

```java
public interface Visitor {
 void visit(final PoorCustomer customer);
 void visit(final RichCustomer customer);
 void visit(final BillGates customer);
}
```

Okey, we got the visitor, but we also need to implement all customer types from above code sample:

```java
public class PoorCustomer implements Customer {
 @Override
 public void accept(final Visitor visitor) {
 visitor.visit(this);
 }

 public String getLittleMoney() {
 return "50$";
 }
}

public class RichCustomer implements Customer {
 @Override
 public void accept(final Visitor visitor) {
 visitor.visit(this);
 }

 public String getALotOfMoney() {
 return "10.000$";
 }
}

public class BillGates implements Customer {
 @Override
 public void accept(final Visitor visitor) {
 visitor.visit(this);
 }

 public String getLololoALotOfMoney() {
 return "1.000.000.000$";
 }
}
```

Implementations are pretty basic - the accept method invokes visitor.visit() with the customer itself (this) as argument.

We also added some custom methods specific to each customer - those methods return an appropriate amount of money.

The last thing we need is an implementation of the visitor that do actions on our customers.
```java
public class DisplayMoney implements Visitor {
 @Override
 public void visit(final PoorCustomer element) {
 System.out.println("Poor customer has " + element.getLittleMoney());
 }

 @Override
 public void visit(final RichCustomer element) {
 System.out.println("Rich customer has " + element.getALotOfMoney());
 }

 @Override
 public void visit(final BillGates element) {
 System.out.println("Bill Gates has " + element.getLololoALotOfMoney());
 }
}
```

As you see, the visitor allows to display money of all types of customers regardless of the differences in their API (getALotOfMoney, getLittleMoney...).

We got all we need to make use of our code - let's use it:

```java
public class Client {
 public static void main(String[] args) {
 final List<Customer> customers = new ArrayList<>();

 // create a list of customers
 customers.add(new BillGates());
 customers.add(new PoorCustomer());
 customers.add(new RichCustomer());

 // create visitor
 final DisplayMoney visitor = new DisplayMoney();

 // execute business logic on all customers
 customers.forEach(customer -> customer.accept(visitor));
 // OUTPUT:
 // Bill Gates has 1.000.000.000$
 // Poor customer has 50$
 // Rich customer has 10.000$
 }
}
```

## Conclusions
Visitor pattern allowed us to put business logic that is applied on a group of elements to a separate class.
Additionally, it can work with different types of elements with different APIs.

To add another operation on the data structure, instead of modifying the code of the structure
we can just implement another visitor.

On the other hand, when we add a new type of element, we might need to update all visitors to support this type.