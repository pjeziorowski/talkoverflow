Template method is a behavioural design pattern that provides a skeleton for an algorithm without
implementing all its steps. It allows its subclasses to provide proper implementations of modifiable parts of the algorithm.

## When to use?
- to define constant parts of the algorithm and let subclasses implement details
- when behaviour common for subclasses should be put in one place to avoid code duplication

## Structure
<Image src="../../assets/template-method.png" alt="template method structure" />

## Elements
- AbstractClass - defines abstract operations to be implemented in subclasses, provides a template method that describes a skeleton of algorithm and lets subclasses provide details of modifiable parts
- ConcreteClass - implements modifiable steps of the algorithm, relies on the abstract class in implementing constant parts of the algorithm

## Consequences
- common code extracted to superclass
- avoids code duplication
- inversion of control - your code calls methods implemented by clients

Constant parts of the algorithm should be implemented in the AbstractClass class. Some steps can have a default implementation and option to be overridden in the subclass. Others should be defined as abstract and provided by ConcreteClasses.

It's important to define which operations are constant, which CAN be implemented and which MUST be implemented.

To make it more convenient for clients, try to minimize the number of methods that MUST be overridden in subclasses.

## Code Example
After all of the theory, let's jump right into a simple implementation of the Template Method.

First, we need to declare AbstractClass with template method and declaration of abstract methods that should be overridden.

```java
public abstract class AbstratClass {
    public final int complicatedMathematicalComputations(final int initialValue) {
        final int afterFirstStep = abstractStep1(initialValue);
        final int afterSecondStep = abstractStep2(afterFirstStep);
        return intLastCommonStep(afterSecondStep);
    }

    protected abstract int abstractStep1(final int val);
    protected abstract int abstractStep2(final int val);

    private final int LastCommonStep(final int val) {
        // I DON'T CARE ABOUT val!
        return 9000;
    }
}
```

`complicatedMathematicalComputations` method is the template method - it uses two abstract methods
as steps in the algorithm, and at the end invokes `lastCommonStep` that is common method with implementation
provided in the abstract class.

It's time to implement abstract methods:

```java
public class ConcreteClass extends AbstratClass {
    @Override
    protected int abstractStep1(int val) {
        return 100 * val;
    }

    @Override
    protected int abstractStep2(int val) {
        return (int) (3.14 * val);
    }
}
```

ConcreteClass provides implementations of abstract steps of the algorithm.

Template method pattern has pretty basic structure, so that's all we need to make use of it.
```java
public class Client {
    public static void main(String[] args) {
        final AbstratClass algorithm = new ConcreteClass();

        System.out.println(algorithm.complicatedMathematicalComputations(100));
        // OUTPUTS: 9000
    }
}
```

## Conclusions
We put constant logic of the algorithm in the abstract class and provided hook methods that
can be overridden in subclasses to define the details of certain parts of the algorithm.

Using the template method, we avoid code duplication by putting common code in abstract class.
We also create room for flexibility by defining abstract parts of the algorithm, which can be then
implemented in various ways in subclasses.